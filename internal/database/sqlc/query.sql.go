// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResourceRecord = `-- name: CreateResourceRecord :one
INSERT INTO resource_records (domain, data, type_id, class_id, time_to_live)
VALUES (
    $1,
    $2,
    (SELECT id FROM types WHERE type = $3),
    (SELECT id FROM classes WHERE class = $4),
    $5
)
RETURNING id
`

type CreateResourceRecordParams struct {
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
}

func (q *Queries) CreateResourceRecord(ctx context.Context, arg CreateResourceRecordParams) (int32, error) {
	row := q.db.QueryRow(ctx, createResourceRecord,
		arg.Domain,
		arg.Data,
		arg.Type,
		arg.Class,
		arg.TimeToLive,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (login, first_name, last_name,password,role_id)
VALUES (
    $1,
    $2,
    $3,
    $4,
    (SELECT roles.id FROM roles WHERE roles.role = $5)
)
RETURNING id
`

type CreateUserParams struct {
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Password  string `db:"password" json:"password"`
	Role      string `db:"role" json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Login,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Role,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteResourceRecord = `-- name: DeleteResourceRecord :exec
DELETE FROM resource_records
WHERE id = $1
`

func (q *Queries) DeleteResourceRecord(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteResourceRecord, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE users.id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAllResourceRecord = `-- name: GetAllResourceRecord :many
SELECT id , domain , data, type_id, class_id , time_to_live ,
(SELECT type FROM types WHERE resource_records.type_id = types.id) AS type,
(SELECT class FROM classes WHERE resource_records.class_id = classes.id) AS class  
 FROM resource_records
`

type GetAllResourceRecordRow struct {
	ID         int32       `db:"id" json:"id"`
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	TypeID     int32       `db:"type_id" json:"type_id"`
	ClassID    int32       `db:"class_id" json:"class_id"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
}

func (q *Queries) GetAllResourceRecord(ctx context.Context) ([]GetAllResourceRecordRow, error) {
	rows, err := q.db.Query(ctx, getAllResourceRecord)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllResourceRecordRow
	for rows.Next() {
		var i GetAllResourceRecordRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Data,
			&i.TypeID,
			&i.ClassID,
			&i.TimeToLive,
			&i.Type,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT users.id, login, first_name, last_name, role
FROM users INNER JOIN roles ON users.role_id = roles.id
`

type GetAllUsersRow struct {
	ID        int32  `db:"id" json:"id"`
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Role      string `db:"role" json:"role"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Login,
			&i.FirstName,
			&i.LastName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceRecordByID = `-- name: GetResourceRecordByID :one
SELECT id , domain , data, type_id, class_id , time_to_live ,
(SELECT type FROM types WHERE resource_records.type_id = types.id) AS type,
(SELECT class FROM classes WHERE resource_records.class_id = classes.id) AS class  
FROM resource_records
WHERE resource_records.id = $1
`

type GetResourceRecordByIDRow struct {
	ID         int32       `db:"id" json:"id"`
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	TypeID     int32       `db:"type_id" json:"type_id"`
	ClassID    int32       `db:"class_id" json:"class_id"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
}

func (q *Queries) GetResourceRecordByID(ctx context.Context, id int32) (GetResourceRecordByIDRow, error) {
	row := q.db.QueryRow(ctx, getResourceRecordByID, id)
	var i GetResourceRecordByIDRow
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Data,
		&i.TypeID,
		&i.ClassID,
		&i.TimeToLive,
		&i.Type,
		&i.Class,
	)
	return i, err
}

const getResourceRecords = `-- name: GetResourceRecords :many
SELECT id , domain , data, type_id, class_id , time_to_live ,
(SELECT type FROM types WHERE resource_records.type_id = types.id) AS type,
(SELECT class FROM classes WHERE resource_records.class_id = classes.id) AS class  
FROM resource_records
WHERE domain = $1 and (SELECT types.type FROM types WHERE types.id = resource_records.type_id) = $2
`

type GetResourceRecordsParams struct {
	Domain string `db:"domain" json:"domain"`
	Type   string `db:"type" json:"type"`
}

type GetResourceRecordsRow struct {
	ID         int32       `db:"id" json:"id"`
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	TypeID     int32       `db:"type_id" json:"type_id"`
	ClassID    int32       `db:"class_id" json:"class_id"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
}

func (q *Queries) GetResourceRecords(ctx context.Context, arg GetResourceRecordsParams) ([]GetResourceRecordsRow, error) {
	rows, err := q.db.Query(ctx, getResourceRecords, arg.Domain, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceRecordsRow
	for rows.Next() {
		var i GetResourceRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Data,
			&i.TypeID,
			&i.ClassID,
			&i.TimeToLive,
			&i.Type,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT users.id, login, first_name, last_name, role, password
FROM users INNER JOIN roles ON users.role_id = roles.id
WHERE users.login = $1
`

type GetUserRow struct {
	ID        int32  `db:"id" json:"id"`
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Role      string `db:"role" json:"role"`
	Password  string `db:"password" json:"password"`
}

func (q *Queries) GetUser(ctx context.Context, login string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, login)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.Password,
	)
	return i, err
}

const updateResourceRecord = `-- name: UpdateResourceRecord :one
UPDATE resource_records
SET domain = $1,
    data = $2, 
    type_id = (SELECT id FROM types WHERE type = $3),
    class_id = (SELECT id FROM classes WHERE class = $4),
    time_to_live = $5
WHERE resource_records.id = $6
RETURNING id
`

type UpdateResourceRecordParams struct {
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	ID         int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateResourceRecord(ctx context.Context, arg UpdateResourceRecordParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateResourceRecord,
		arg.Domain,
		arg.Data,
		arg.Type,
		arg.Class,
		arg.TimeToLive,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET login = $2, first_name = $3, last_name = $4, 
    role_id = (SELECT id FROM roles WHERE role = $5 AND role IS NOT NULL),
    password = $6
WHERE users.id = $1
`

type UpdateUserParams struct {
	ID        int32  `db:"id" json:"id"`
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Role      string `db:"role" json:"role"`
	Password  string `db:"password" json:"password"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Login,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.Password,
	)
	return err
}
