// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResourceRecord = `-- name: CreateResourceRecord :one
INSERT INTO resource_records (domain, data, type_id, class_id, time_to_live)
VALUES (
    $1,
    $2,
    (SELECT id FROM types WHERE type = $3),
    (SELECT id FROM classes WHERE class = $4),
    $5
)
RETURNING id, domain, data, type_id, class_id, time_to_live
`

type CreateResourceRecordParams struct {
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
}

func (q *Queries) CreateResourceRecord(ctx context.Context, arg CreateResourceRecordParams) (ResourceRecord, error) {
	row := q.db.QueryRow(ctx, createResourceRecord,
		arg.Domain,
		arg.Data,
		arg.Type,
		arg.Class,
		arg.TimeToLive,
	)
	var i ResourceRecord
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Data,
		&i.TypeID,
		&i.ClassID,
		&i.TimeToLive,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (login, first_name, last_name,password,role_id)
VALUES (
    $1,
    $2,
    $3,
    $4,
    (SELECT roles.id FROM roles WHERE roles.role = $5)
)
RETURNING id, login, first_name, last_name, password, role_id
`

type CreateUserParams struct {
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Password  string `db:"password" json:"password"`
	Role      string `db:"role" json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Login,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.RoleID,
	)
	return i, err
}

const deleteResourceRecord = `-- name: DeleteResourceRecord :one
DELETE FROM resource_records
WHERE id = $1
RETURNING id, domain, data, type_id, class_id, time_to_live
`

func (q *Queries) DeleteResourceRecord(ctx context.Context, id int32) (ResourceRecord, error) {
	row := q.db.QueryRow(ctx, deleteResourceRecord, id)
	var i ResourceRecord
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Data,
		&i.TypeID,
		&i.ClassID,
		&i.TimeToLive,
	)
	return i, err
}

const getAllResourceRecord = `-- name: GetAllResourceRecord :many
SELECT id , domain , data, type_id, class_id , time_to_live ,
(SELECT type FROM types WHERE resource_records.type_id = types.id) AS type,
(SELECT class FROM classes WHERE resource_records.class_id = classes.id) AS class  
 FROM resource_records
`

type GetAllResourceRecordRow struct {
	ID         int32       `db:"id" json:"id"`
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	TypeID     int32       `db:"type_id" json:"type_id"`
	ClassID    int32       `db:"class_id" json:"class_id"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
}

func (q *Queries) GetAllResourceRecord(ctx context.Context) ([]GetAllResourceRecordRow, error) {
	rows, err := q.db.Query(ctx, getAllResourceRecord)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllResourceRecordRow
	for rows.Next() {
		var i GetAllResourceRecordRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Data,
			&i.TypeID,
			&i.ClassID,
			&i.TimeToLive,
			&i.Type,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceRecords = `-- name: GetResourceRecords :many
SELECT id , domain , data, type_id, class_id , time_to_live ,
(SELECT type FROM types WHERE resource_records.type_id = types.id) AS type,
(SELECT class FROM classes WHERE resource_records.class_id = classes.id) AS class  
FROM resource_records
WHERE domain = $1 and (SELECT types.type FROM types WHERE types.id = resource_records.type_id) = $2
`

type GetResourceRecordsParams struct {
	Domain string `db:"domain" json:"domain"`
	Type   string `db:"type" json:"type"`
}

type GetResourceRecordsRow struct {
	ID         int32       `db:"id" json:"id"`
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	TypeID     int32       `db:"type_id" json:"type_id"`
	ClassID    int32       `db:"class_id" json:"class_id"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
}

func (q *Queries) GetResourceRecords(ctx context.Context, arg GetResourceRecordsParams) ([]GetResourceRecordsRow, error) {
	rows, err := q.db.Query(ctx, getResourceRecords, arg.Domain, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceRecordsRow
	for rows.Next() {
		var i GetResourceRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Data,
			&i.TypeID,
			&i.ClassID,
			&i.TimeToLive,
			&i.Type,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT login, first_name, last_name, role, password
FROM users INNER JOIN roles ON users.role_id = roles.id
WHERE users.login = $1
`

type GetUserRow struct {
	Login     string `db:"login" json:"login"`
	FirstName string `db:"first_name" json:"first_name"`
	LastName  string `db:"last_name" json:"last_name"`
	Role      string `db:"role" json:"role"`
	Password  string `db:"password" json:"password"`
}

func (q *Queries) GetUser(ctx context.Context, login string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, login)
	var i GetUserRow
	err := row.Scan(
		&i.Login,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.Password,
	)
	return i, err
}

const updateResourceRecord = `-- name: UpdateResourceRecord :one
UPDATE resource_records
SET domain = $1,
    data = $2, 
    type_id = (SELECT id FROM types WHERE type = $3),
    class_id = (SELECT id FROM classes WHERE class = $4),
    time_to_live = $5
WHERE resource_records.id = $6
RETURNING id, domain, data, type_id, class_id, time_to_live
`

type UpdateResourceRecordParams struct {
	Domain     string      `db:"domain" json:"domain"`
	Data       string      `db:"data" json:"data"`
	Type       string      `db:"type" json:"type"`
	Class      string      `db:"class" json:"class"`
	TimeToLive pgtype.Int4 `db:"time_to_live" json:"time_to_live"`
	ID         int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateResourceRecord(ctx context.Context, arg UpdateResourceRecordParams) (ResourceRecord, error) {
	row := q.db.QueryRow(ctx, updateResourceRecord,
		arg.Domain,
		arg.Data,
		arg.Type,
		arg.Class,
		arg.TimeToLive,
		arg.ID,
	)
	var i ResourceRecord
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Data,
		&i.TypeID,
		&i.ClassID,
		&i.TimeToLive,
	)
	return i, err
}
